---
dg-publish: true
---
# Book Review: The Art of Unix Programming

#livro/nerd #unix

## Por que eu li esse livro?

No meu trabalho fui incumbido de fazer uma apresentação sobre Microsserviços, e durante minhas pesquisas eu via frequentes menções à "filosofia Unix".

Lembrei que tinha esse livro na minha (enorme) lista de "livros que quero ler" e resolvi pegar pra ler.

## O livro em 3 frases

1. Conhecimento útil e relevante para qualquer programador (não apenas para aqueles que lidam com ambientes Unix-like).
2. A "Filosofia Unix" é na verdade um outro termo para se referir a "como pensar" quando precisa resolver problemas através de software.
3. ???

## Citações

> Those who do not understand Unix are condemned to reinvent it, poorly.
-- Henry Spencer Usenet signature, November 1987

---

Um sinal de que conhecer sobre as "fundações" (ou "princípios fundamentais") de um determinado assunto é uma atitude que vale a pena:

> Machines have increased a thousandfold in power, languages have mutated, industry practice has gone through multiple revolutions - and Unix hangs in there, still producing, still paying the bills, and still commanding loyalty from many of the best and brightest software technologists on the planet.

---

> (...) users know better than operating-system designers what their own needs are.
> (...) "it's better to solve the right problem the wrong way than the wrong problem the right way."

Entendi isso como "a importância de empoderar os leigos em programação."

---

### Filosofia Unix

"Regras" derivadas da filosofia Unix:

1. [[Regra da Modularidade]]: Escreva partes simples conectadas por interfaces limpas.
2. [[Regra da Clareza]]: Clareza é mais importante que esperteza.
3. [[Regra da Composicao]]: Projete programas para serem conectados a outros programas.
4. [[Regra da Separacao]]: Separe política do mecanismo; separe interfaces dos motores.
5. [[Regra da Simplicidade]]: Projete para simplicidade; adiciona complexidade apenas onde você precisa.
6. [[Regra da Parsimonia]]: Escreva um programa grande apenas quando é claro por demonstração que nada mais serve.
7. [[Regra da Transparencia]]: Projete para visibilidadade para tornar mais fácil a inspeção e depuração.
8. [[Regra da Robustez]]: Robustez é o filho da transparência e simplicidade.
9. [[Regra da Representacao]]: Agrupe conhecimento em dados para que a lógica do programa seja estúpida e robusta.
10. [[Regra da Menor Surpresa]]: Ao projetar interfaces, sempre faça a coisa menos surpreendente.
11. [[Regra do Silencio]]: Quando um programa não tem nada surpreendente para dizer, ele deve dizer nada.
12. [[Regra do Reparo]]: Quando precisar falhar, falhe ruidosamente e o mais rápido possível.
13. [[Regra da Economia]]: O tempo do programador é caro; conserve-o em preferência ao tempo de máquina. (Minha observação: a intenção é economizar tempo do mantenedor do código, escrevendo código claro em preferência a código performático e obscuro.)
14. [[Regra da Geracao]]: Evite hacking manual; escreva programas para escrever programas quando puder.
15. [[Regra da Otimizacao]]: Faça um protótipo antes de polir. Deixe funcionando antes de otimizar.
16. [[Regra da Diversidade]]: Desconfie de todas reivindicações de "o caminho verdadeiro".
17. [[Regra da Extensibilidade]]: Projete para o futuro, pois ele estará aqui mais cedo do que você pensa.


## O que eu aprendi?

## Comentários

## Outros livros mencionados

- The Design of the Unix Operating System
- The Unix Programming Environment
- The Pragmatic Programmer
- The Practice of Programming
- Zen Flesh, Zen Bones


## Anki Cards

TARGET DECK: programming

Número de regras da filosofia Unix? #flashcard 
17
<!--ID: 1627938988782-->


1. Regra da Modularidade (Unix) #flashcard 
Escreva partes simples conectadas por interfaces limpas.
<!--ID: 1627938988787-->


2. Regra da Clareza (Unix) #flashcard 
Clareza é mais importante que esperteza.
<!--ID: 1627938988791-->


3. Regra da Composicao (Unix) #flashcard 
Projete programas para serem conectados a outros programas.
<!--ID: 1627938988795-->


4. Regra da Separacao (Unix) #flashcard 
Separe política do mecanismo; separe interfaces dos motores.
<!--ID: 1627938988799-->


5. Regra da Simplicidade (Unix) #flashcard 
Projete para simplicidade; adiciona complexidade apenas onde você precisa.
<!--ID: 1627938988803-->


6. Regra da Parsimonia (Unix) #flashcard 
Escreva um programa grande apenas quando é claro por demonstração que nada mais serve.
<!--ID: 1627938988807-->


7. Regra da Transparencia (Unix) #flashcard 
Projete para visibilidadade para tornar mais fácil a inspeção e depuração.
<!--ID: 1627938988811-->


8. Regra da Robustez (Unix) #flashcard 
Robustez é o filho da transparência e simplicidade.
<!--ID: 1627938988815-->


9. Regra da Representacao (Unix) #flashcard 
Agrupe conhecimento em dados para que a lógica do programa seja estúpida e robusta.
<!--ID: 1627938988819-->


10. Regra da Menor Surpresa (Unix) #flashcard 
Ao projetar interfaces, sempre faça a coisa menos surpreendente.
<!--ID: 1627938988823-->


11. Regra do Silencio (Unix) #flashcard 
Quando um programa não tem nada surpreendente para dizer, ele deve dizer nada.
<!--ID: 1627938988827-->


12. Regra do Reparo (Unix) #flashcard 
Quando precisar falhar, falhe ruidosamente e o mais rápido possível.
<!--ID: 1627938988831-->


13. Regra da Economia (Unix) #flashcard 
O tempo do programador é caro; conserve-o em preferência ao tempo de máquina.
<!--ID: 1627938988835-->


14. Regra da Geracao (Unix) #flashcard 
Evite hacking manual; escreva programas para escrever programas quando puder.
<!--ID: 1627938988839-->


15. Regra da Otimizacao (Unix) #flashcard 
Faça um protótipo antes de polir. Deixe funcionando antes de otimizar.
<!--ID: 1627938988844-->


16. Regra da Diversidade (Unix) #flashcard 
Desconfie de todas reivindicações de "o caminho verdadeiro".
<!--ID: 1627938988848-->


17. Regra da Extensibilidade (Unix) #flashcard 
Projete para o futuro, pois ele estará aqui mais cedo do que você pensa.
<!--ID: 1627938988852-->


